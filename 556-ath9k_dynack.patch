Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/ath9k.h
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/ath9k.h	2013-06-15 16:20:17.701822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/ath9k.h	2013-06-15 16:25:54.549822187 +0200
@@ -27,6 +27,7 @@
 #include "common.h"
 #include "mci.h"
 #include "dfs.h"
+#include "dynack.h"
 
 /*
  * Header for the ath9k.ko driver core *only* -- hw code nor any other driver
@@ -269,6 +270,9 @@
 
 	bool sleeping;
 
+	u16 ack_to;
+	struct list_head list;
+
 #if defined(CONFIG_MAC80211_DEBUGFS) && defined(CONFIG_ATH9K_DEBUGFS)
 	struct dentry *node_stat;
 #endif
@@ -780,6 +784,10 @@
 	atomic_t wow_sleep_proc_intr; /* in the middle of WoW sleep ? */
 	u32 wow_intr_before_sleep;
 #endif
+	struct mutex nodes_mtx;
+	struct list_head nodes;
+
+	struct ath_dynack dynack;
 };
 
 #define SPECTRAL_SCAN_BITMASK		0x10
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/init.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/init.c	2013-06-15 16:20:17.701822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/init.c	2013-07-01 00:59:54.729012000 +0200
@@ -621,6 +621,7 @@
 	spin_lock_init(&sc->sc_serial_rw);
 	spin_lock_init(&sc->sc_pm_lock);
 	mutex_init(&sc->mutex);
+	mutex_init(&sc->nodes_mtx);
 #ifdef CONFIG_ATH9K_MAC_DEBUG
 	spin_lock_init(&sc->debug.samp_lock);
 #endif
@@ -634,6 +635,7 @@
 	INIT_DELAYED_WORK(&sc->hw_pll_work, ath_hw_pll_work);
 	setup_timer(&sc->rx_poll_timer, ath_rx_poll, (unsigned long)sc);
 
+	INIT_LIST_HEAD(&sc->nodes);
 	/*
 	 * Cache line size is used to size and align various
 	 * structures used to communicate with the hardware.
@@ -674,6 +676,8 @@
 	if (common->bus_ops->aspm_init)
 		common->bus_ops->aspm_init(common);
 
+	ath_dynack_init(sc);
+
 	return 0;
 
 err_btcoex:
@@ -949,6 +953,7 @@
 			ath_tx_cleanupq(sc, &sc->tx.txq[i]);
 
 	ath9k_hw_deinit(sc->sc_ah);
+	ath_dynack_deinit(sc);
 	if (sc->dfs_detector != NULL)
 		sc->dfs_detector->exit(sc->dfs_detector);
 
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/main.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/main.c	2013-06-15 16:20:17.701822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/main.c	2013-07-04 23:56:41.442733000 +0200
@@ -330,6 +330,10 @@
 	an->sta = sta;
 	an->vif = vif;
 
+	mutex_lock(&sc->nodes_mtx);
+	list_add(&an->list, &sc->nodes);
+	mutex_unlock(&sc->nodes_mtx);
+
 	ath_tx_node_init(sc, an);
 
 	if (sta->ht_cap.ht_supported) {
@@ -342,6 +346,11 @@
 static void ath_node_detach(struct ath_softc *sc, struct ieee80211_sta *sta)
 {
 	struct ath_node *an = (struct ath_node *)sta->drv_priv;
+
+	mutex_lock(&sc->nodes_mtx);
+	list_del(&an->list);
+	mutex_unlock(&sc->nodes_mtx);
+
 	ath_tx_node_cleanup(sc, an);
 }
 
@@ -1802,6 +1811,9 @@
 	mutex_lock(&sc->mutex);
 	ah->coverage_class = coverage_class;
 
+	sc->dynack.fix_to = true;
+	ath_dynack_deinit(sc);
+
 	ath9k_ps_wakeup(sc);
 	ath9k_hw_init_global_settings(ah);
 	ath9k_ps_restore(sc);
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/dynack.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/dynack.h	2013-07-04 23:40:16.706733000 +0200
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2013-2014, Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef ATH9K_DYNACK_H
+#define ATH9K_DYNACK_H
+
+/**
+ * ath_dynack - dyn ack processing info
+ * @fix_to: use static ack timeout
+ *
+ */
+struct ath_dynack {
+	bool fix_to;
+};
+
+void ath_dynack_init(struct ath_softc *sc);
+void ath_dynack_deinit(struct ath_softc *sc);
+void ath_dynack_sample_tx_ts(struct ath_softc *sc, struct sk_buff *skb,
+			     struct ath_tx_status *ts);
+void ath_dynack_sample_ack_ts(struct ath_softc *sc, struct sk_buff *skb,
+			      u64 ts);
+#endif /* ATH9K_DYNACK_H */
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/Makefile
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/Makefile	2013-04-19 13:53:52.000000000 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/Makefile	2013-06-15 16:52:03.497822187 +0200
@@ -5,7 +5,8 @@
 		recv.o \
 		xmit.o \
 		link.o \
-		antenna.o
+		antenna.o \
+		dynack.o
 
 ath9k-$(CONFIG_ATH9K_BTCOEX_SUPPORT) += mci.o
 ath9k-$(CONFIG_COMPAT_ATH9K_RATE_CONTROL) += rc.o
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/dynack.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/dynack.c	2013-07-04 23:58:46.310733000 +0200
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2013-2014, Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "ath9k.h"
+
+/**
+ * ath_dynack_init - init dyn ack data structures
+ * @sc: soft carrier
+ *
+ */
+void ath_dynack_init(struct ath_softc *sc)
+{
+}
+
+void ath_dynack_deinit(struct ath_softc *sc)
+{
+}
+
+/**
+ * ath_dynack_sample_tx_ts - status ts sampling method
+ * @sc: soft carrier
+ * @skb: socket buffer
+ * @ts: tx status info
+ *
+ */
+void ath_dynack_sample_tx_ts(struct ath_softc *sc, struct sk_buff *skb,
+			     struct ath_tx_status *ts)
+{
+}
+
+/**
+ * ath_dynack_sample_ack_ts - ack ts sampling method
+ * @sc: soft carrier
+ * @skb: socket buffer
+ * @ts: rx timestamp
+ *
+ */
+void ath_dynack_sample_ack_ts(struct ath_softc *sc, struct sk_buff *skb,
+			      u64 ts)
+{
+}
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/recv.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/recv.c	2013-06-15 16:19:16.849822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/recv.c	2013-07-01 00:44:37.593012000 +0200
@@ -27,6 +27,19 @@
 	       (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP);
 }
 
+static bool ath9k_check_bssidmask(struct ath_softc *sc, u8 *mac)
+{
+	int i;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+
+	for (i = 0; i < ETH_ALEN; i++) {
+		if ((common->macaddr[i] & common->bssidmask[i]) !=
+		    (mac[i] & common->bssidmask[i]))
+			return false;
+	}
+	return true;
+}
+
 /*
  * Setup and link descriptors.
  *
@@ -379,7 +392,7 @@
 	u32 rfilt;
 
 	rfilt = ATH9K_RX_FILTER_UCAST | ATH9K_RX_FILTER_BCAST
-		| ATH9K_RX_FILTER_MCAST;
+		| ATH9K_RX_FILTER_MCAST | ATH9K_RX_FILTER_CONTROL;
 
 	/* if operating on a DFS channel, enable radar pulse detection */
 	if (sc->hw->conf.radar_enabled)
@@ -396,9 +409,6 @@
 	if (sc->sc_ah->is_monitoring)
 		rfilt |= ATH9K_RX_FILTER_PROM;
 
-	if (sc->rx.rxfilter & FIF_CONTROL)
-		rfilt |= ATH9K_RX_FILTER_CONTROL;
-
 	if ((sc->sc_ah->opmode == NL80211_IFTYPE_STATION) &&
 	    (sc->nvifs <= 1) &&
 	    !(sc->rx.rxfilter & FIF_BCN_PRBRESP_PROMISC))
@@ -1387,6 +1397,10 @@
 
 		ath9k_apply_ampdu_details(sc, &rs, rxs);
 
+		if (ieee80211_is_ack(hdr->frame_control) &&
+		    ath9k_check_bssidmask(sc, hdr->addr1))
+			ath_dynack_sample_ack_ts(sc, skb, rs.rs_tstamp);
+
 		ieee80211_rx(hw, skb);
 
 requeue_drop_frag:
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/ar9002_mac.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/ar9002_mac.c	2013-04-19 13:53:51.000000000 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/ar9002_mac.c	2013-07-01 00:58:23.317012000 +0200
@@ -341,6 +341,13 @@
 	ts->evm1 = ads->AR_TxEVM1;
 	ts->evm2 = ads->AR_TxEVM2;
 
+	status = ACCESS_ONCE(ads->ds_ctl4);
+	ts->duration[0] = MS(status, AR_PacketDur0);
+	ts->duration[1] = MS(status, AR_PacketDur1);
+	status = ACCESS_ONCE(ads->ds_ctl5);
+	ts->duration[2] = MS(status, AR_PacketDur2);
+	ts->duration[3] = MS(status, AR_PacketDur3);
+
 	return 0;
 }
 
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/mac.h
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/mac.h	2013-06-15 16:19:16.849822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/mac.h	2013-07-01 00:48:24.361012000 +0200
@@ -121,6 +121,7 @@
 	u32 evm0;
 	u32 evm1;
 	u32 evm2;
+	u16 duration[4];
 };
 
 struct ath_rx_status {
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/xmit.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/xmit.c	2013-06-15 16:19:16.417822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/xmit.c	2013-07-04 23:59:07.546733000 +0200
@@ -613,6 +613,7 @@
 			memcpy(info->control.rates, bf->rates,
 			       sizeof(info->control.rates));
 			ath_tx_rc_status(sc, bf, ts, 1, txok ? 0 : 1, txok);
+				ath_dynack_sample_tx_ts(sc, bf->bf_mpdu, ts);
 		}
 		ath_tx_complete_buf(sc, bf, txq, bf_head, ts, txok);
 	} else
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/debug.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/debug.c	2013-06-15 16:19:17.017822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/debug.c	2013-07-05 00:01:24.674733000 +0200
@@ -2201,6 +2201,54 @@
 	.llseek = default_llseek,
 };
 
+static ssize_t read_file_ack_to(struct file *file, char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	char buf[32];
+	unsigned int len, to = ath9k_hw_get_ack_timeout(sc->sc_ah);
+
+	len = sprintf(buf, "%u %c\n", to, (sc->dynack.fix_to) ? 'S' : 'A');
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+/*
+ * enable/disable dynack processing
+ */
+static ssize_t write_file_ack_to(struct file *file, const char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	char buf[32];
+	unsigned long ack_to;
+	ssize_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	if (kstrtoul(buf, 0, &ack_to))
+			return -EINVAL;
+
+	sc->dynack.fix_to = !ack_to;
+
+	/* XXX: remove workqueue */
+	if (sc->dynack.fix_to) {
+		ath9k_hw_set_ack_timeout(sc->sc_ah, ack_to);
+	} else ;
+
+	return count;
+}
+
+static const struct file_operations fops_ack_to = {
+	.read = read_file_ack_to,
+	.write = write_file_ack_to,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
 
 int ath9k_init_debug(struct ath_hw *ah)
 {
@@ -2306,5 +2354,8 @@
 	debugfs_create_file("btcoex", S_IRUSR, sc->debug.debugfs_phy, sc,
 			    &fops_btcoex);
 #endif
+	debugfs_create_file("ack_to", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_ack_to);
+
 	return 0;
 }
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/hw.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/hw.c	2013-06-15 16:19:17.061822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/hw.c	2013-07-04 23:42:04.330733000 +0200
@@ -1007,6 +1007,15 @@
 	REG_WRITE(ah, AR_D_GBL_IFS_SIFS, val);
 }
 
+u32 ath9k_hw_get_sifs_time(struct ath_hw *ah)
+{
+	u32 val = REG_READ(ah, AR_D_GBL_IFS_SIFS);
+	struct ath_common *common = ath9k_hw_common(ah);
+
+	return  (common->clockrate) ? val / common->clockrate : 0;
+}
+EXPORT_SYMBOL(ath9k_hw_get_sifs_time);
+
 static void ath9k_hw_setslottime(struct ath_hw *ah, u32 us)
 {
 	u32 val = ath9k_hw_mac_to_clks(ah, us);
@@ -1014,12 +1023,31 @@
 	REG_WRITE(ah, AR_D_GBL_IFS_SLOT, val);
 }
 
-static void ath9k_hw_set_ack_timeout(struct ath_hw *ah, u32 us)
+u32 ath9k_hw_get_slot_time(struct ath_hw *ah)
+{
+	u32 val = REG_READ(ah, AR_D_GBL_IFS_SLOT);
+	struct ath_common *common = ath9k_hw_common(ah);
+
+	return  (common->clockrate) ? val / common->clockrate : 0;
+}
+EXPORT_SYMBOL(ath9k_hw_get_slot_time);
+
+void ath9k_hw_set_ack_timeout(struct ath_hw *ah, u32 us)
 {
 	u32 val = ath9k_hw_mac_to_clks(ah, us);
 	val = min(val, (u32) MS(0xFFFFFFFF, AR_TIME_OUT_ACK));
 	REG_RMW_FIELD(ah, AR_TIME_OUT, AR_TIME_OUT_ACK, val);
 }
+EXPORT_SYMBOL(ath9k_hw_set_ack_timeout);
+
+u32 ath9k_hw_get_ack_timeout(struct ath_hw *ah)
+{
+	u32 val = REG_READ_FIELD(ah, AR_TIME_OUT, AR_TIME_OUT_ACK);
+	struct ath_common *common = ath9k_hw_common(ah);
+
+	return  (common->clockrate) ? val / common->clockrate : 0;
+}
+EXPORT_SYMBOL(ath9k_hw_get_ack_timeout);
 
 static void ath9k_hw_set_cts_timeout(struct ath_hw *ah, u32 us)
 {
@@ -1045,6 +1073,7 @@
 void ath9k_hw_init_global_settings(struct ath_hw *ah)
 {
 	struct ath_common *common = ath9k_hw_common(ah);
+	struct ath_softc *sc = common->priv;
 	struct ieee80211_conf *conf = &common->hw->conf;
 	const struct ath9k_channel *chan = ah->curchan;
 	int acktimeout, ctstimeout, ack_offset = 0;
@@ -1129,7 +1158,10 @@
 
 	ath9k_hw_set_sifs_time(ah, sifstime);
 	ath9k_hw_setslottime(ah, slottime);
-	ath9k_hw_set_ack_timeout(ah, acktimeout);
+
+	if (sc->dynack.fix_to)
+		ath9k_hw_set_ack_timeout(ah, acktimeout);
+
 	ath9k_hw_set_cts_timeout(ah, ctstimeout);
 	if (ah->globaltxtimeout != (u32) -1)
 		ath9k_hw_set_global_txtimeout(ah, ah->globaltxtimeout);
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/hw.h
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/hw.h	2013-06-15 16:19:17.061822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/hw.h	2013-07-04 23:32:18.910733000 +0200
@@ -1039,6 +1039,11 @@
 bool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode);
 void ath9k_hw_update_diag(struct ath_hw *ah);
 
+u32 ath9k_hw_get_sifs_time(struct ath_hw *ah);
+u32 ath9k_hw_get_ack_timeout(struct ath_hw *ah);
+u32 ath9k_hw_get_slottime(struct ath_hw *ah);
+void ath9k_hw_set_ack_timeout(struct ath_hw *ah, u32 us);
+
 #ifdef CONFIG_ATH9K_DEBUGFS
 void ath9k_debug_sync_cause(struct ath_common *common, u32 sync_cause);
 #else
