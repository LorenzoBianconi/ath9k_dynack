Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/ath9k.h
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/ath9k.h	2013-06-15 16:20:17.701822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/ath9k.h	2013-07-09 23:09:26.341387000 +0200
@@ -27,6 +27,7 @@
 #include "common.h"
 #include "mci.h"
 #include "dfs.h"
+#include "dynack.h"
 
 /*
  * Header for the ath9k.ko driver core *only* -- hw code nor any other driver
@@ -269,6 +270,9 @@
 
 	bool sleeping;
 
+	u16 ackto;
+	struct list_head list;
+
 #if defined(CONFIG_MAC80211_DEBUGFS) && defined(CONFIG_ATH9K_DEBUGFS)
 	struct dentry *node_stat;
 #endif
@@ -780,6 +784,10 @@
 	atomic_t wow_sleep_proc_intr; /* in the middle of WoW sleep ? */
 	u32 wow_intr_before_sleep;
 #endif
+	struct mutex nodes_mtx;
+	struct list_head nodes;
+
+	struct ath_dynack dynack;
 };
 
 #define SPECTRAL_SCAN_BITMASK		0x10
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/init.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/init.c	2013-06-15 16:20:17.701822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/init.c	2013-07-08 02:12:17.914862999 +0200
@@ -621,6 +621,7 @@
 	spin_lock_init(&sc->sc_serial_rw);
 	spin_lock_init(&sc->sc_pm_lock);
 	mutex_init(&sc->mutex);
+	mutex_init(&sc->nodes_mtx);
 #ifdef CONFIG_ATH9K_MAC_DEBUG
 	spin_lock_init(&sc->debug.samp_lock);
 #endif
@@ -634,6 +635,7 @@
 	INIT_DELAYED_WORK(&sc->hw_pll_work, ath_hw_pll_work);
 	setup_timer(&sc->rx_poll_timer, ath_rx_poll, (unsigned long)sc);
 
+	INIT_LIST_HEAD(&sc->nodes);
 	/*
 	 * Cache line size is used to size and align various
 	 * structures used to communicate with the hardware.
@@ -674,6 +676,8 @@
 	if (common->bus_ops->aspm_init)
 		common->bus_ops->aspm_init(common);
 
+	ath_dynack_init(sc);
+
 	return 0;
 
 err_btcoex:
@@ -949,6 +953,7 @@
 			ath_tx_cleanupq(sc, &sc->tx.txq[i]);
 
 	ath9k_hw_deinit(sc->sc_ah);
+	ath_dynack_deinit(sc);
 	if (sc->dfs_detector != NULL)
 		sc->dfs_detector->exit(sc->dfs_detector);
 
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/main.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/main.c	2013-06-15 16:20:17.701822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/main.c	2013-07-09 22:59:15.857387000 +0200
@@ -330,6 +330,10 @@
 	an->sta = sta;
 	an->vif = vif;
 
+	mutex_lock(&sc->nodes_mtx);
+	list_add_tail_rcu(&an->list, &sc->nodes);
+	mutex_unlock(&sc->nodes_mtx);
+
 	ath_tx_node_init(sc, an);
 
 	if (sta->ht_cap.ht_supported) {
@@ -342,6 +346,13 @@
 static void ath_node_detach(struct ath_softc *sc, struct ieee80211_sta *sta)
 {
 	struct ath_node *an = (struct ath_node *)sta->drv_priv;
+
+	mutex_lock(&sc->nodes_mtx);
+	list_del_rcu(&an->list);
+	mutex_unlock(&sc->nodes_mtx);
+
+	synchronize_rcu();
+
 	ath_tx_node_cleanup(sc, an);
 }
 
@@ -1802,6 +1813,9 @@
 	mutex_lock(&sc->mutex);
 	ah->coverage_class = coverage_class;
 
+	sc->dynack.fix_to = true;
+	ath_dynack_deinit(sc);
+
 	ath9k_ps_wakeup(sc);
 	ath9k_hw_init_global_settings(ah);
 	ath9k_ps_restore(sc);
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/dynack.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/dynack.h	2013-07-10 01:40:14.213387000 +0200
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2013-2014, Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef ATH9K_DYNACK_H
+#define ATH9K_DYNACK_H
+
+#define ATH_DYN_BUF		64
+#define ATH_DYN_MAX_DELAY	300
+#define ATH_DYN_EWMA		75
+#define ATH_DYN_COMPUTE_TO	(30 * HZ)
+#define ATH_DYN_LATE_ACK_TO	(30 * HZ)
+
+struct ts_info {
+	int tstamp;
+	int dur;
+};
+
+/**
+ * ath_dyn_buf - ts ring buffer
+ */
+struct ath_dyn_buf {
+	u16 h_rb, t_rb;
+	struct ts_info ts[ATH_DYN_BUF];
+};
+
+/**
+ * ath_dynack - dyn ack processing info
+ * @fix_to: use static ack timeout
+ * @lcompute_ts: last ack timeout computation
+ * @qlock: ts queue spinlock
+ * @ack_rbf: ack ts ring buffer
+ * @st_rbf: status ts ring buffer
+ * @stalist: sta list ts ring buffer
+ */
+struct ath_dynack {
+	bool fix_to;
+	unsigned long lcompute_ts;
+
+	spinlock_t qlock;
+	struct ath_dyn_buf ack_rbf, st_rbf;
+	struct ieee80211_sta *stalist[ATH_DYN_BUF];
+};
+
+void ath_dynack_init(struct ath_softc *sc);
+void ath_dynack_deinit(struct ath_softc *sc);
+void ath_dynack_sample_tx_ts(struct ath_softc *sc, struct sk_buff *skb,
+			     struct ath_tx_status *ts);
+void ath_dynack_sample_ack_ts(struct ath_softc *sc, struct sk_buff *skb,
+			      u64 ts);
+#endif /* ATH9K_DYNACK_H */
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/Makefile
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/Makefile	2013-04-19 13:53:52.000000000 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/Makefile	2013-06-15 16:52:03.497822187 +0200
@@ -5,7 +5,8 @@
 		recv.o \
 		xmit.o \
 		link.o \
-		antenna.o
+		antenna.o \
+		dynack.o
 
 ath9k-$(CONFIG_ATH9K_BTCOEX_SUPPORT) += mci.o
 ath9k-$(CONFIG_COMPAT_ATH9K_RATE_CONTROL) += rc.o
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/dynack.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/dynack.c	2013-07-10 01:53:27.937387000 +0200
@@ -0,0 +1,275 @@
+/*
+ * Copyright 2013-2014, Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "ath9k.h"
+
+#define ATH_DYNACK_EWMA(old, new, weight)		\
+	(((new) * (100 - (weight)) + (old) * weight) / 100)
+
+/*
+ * ath_dynack_get_sifs - get sifs time based on phy used
+ * @sc: soft carrier
+ * @phy: phy used
+ */
+static inline u16 ath_dynack_get_sifs(struct ath_softc *sc, int phy)
+{
+	u16 sifs = CCK_SIFS_TIME;
+
+	if (phy == WLAN_RC_PHY_OFDM) {
+		if (IS_CHAN_QUARTER_RATE(sc->sc_ah->curchan))
+			sifs = OFDM_SIFS_TIME_QUARTER;
+		else if (IS_CHAN_HALF_RATE(sc->sc_ah->curchan))
+			sifs = OFDM_SIFS_TIME_HALF;
+		else
+			sifs = OFDM_SIFS_TIME;
+	}
+	return sifs;
+}
+
+/**
+ * ath_dynack_min_to - get minimum ack timeout
+ * as defined by IEEE 802.11-2007 17.3.8.6
+ * @sc: soft carrier
+ *
+ */
+static inline u32 ath_dynack_min_to(struct ath_softc *sc)
+{
+	const struct ath9k_channel *chan = sc->sc_ah->curchan;
+	u32 slottime = sc->sc_ah->slottime, ack_offset = 0;
+	u32 sifs = (IS_CHAN_5GHZ(chan)) ? 16 : 10;
+
+	if (IS_CHAN_QUARTER_RATE(chan)) {
+		sifs *= 4;
+		slottime = 21;
+		ack_offset = 32;
+	} else if (IS_CHAN_HALF_RATE(chan)) {
+		sifs *= 2;
+		slottime = 13;
+		ack_offset = 16;
+	}
+
+	return slottime + sifs + ack_offset;
+}
+
+/**
+ * ath_dynack_set_ackto - compute ack timeout based on sta timeout
+ * @sc: soft carrier
+ */
+static void ath_dynack_compute_ackto(struct ath_softc *sc)
+{
+	struct ath_node *an;
+	u16 to = 0, ackto = ath9k_hw_get_ack_timeout(sc->sc_ah);
+
+	list_for_each_entry_rcu(an, &sc->nodes, list) {
+		if (an->ackto > to)
+			to = an->ackto;
+	}
+	if (to && ackto != to) {
+#ifdef CONFIG_ATH9K_DYNACK_DEBUG
+		printk(KERN_DEBUG "%s: ack timeout %u\n", __func__, ackto);
+#endif
+		ath9k_hw_set_ack_timeout(sc->sc_ah, ackto);
+		ath9k_hw_set_cts_timeout(sc->sc_ah, ackto);
+	}
+}
+
+/**
+ * ath_dynack_compute_to - compute sta ack timeout
+ * @sc: soft carrier
+ *
+ * should be called while holding qlock
+ */
+static void ath_dynack_compute_to(struct ath_softc *sc)
+{
+
+	unsigned long compute_ts;
+	int delay, min_to = ath_dynack_min_to(sc);
+	struct ath_node *an = NULL;
+	struct ieee80211_sta *sta = NULL;
+	struct ath_dynack *da = &sc->dynack;
+	u16 *ack_h = &da->ack_rbf.h_rb, *st_h = &da->st_rbf.h_rb;
+	struct ts_info *ack_ts = &da->ack_rbf.ts[*ack_h];
+	struct ts_info *st_ts = &da->st_rbf.ts[*st_h];
+
+	while (da->st_rbf.h_rb != da->st_rbf.t_rb &&
+	       da->ack_rbf.h_rb != da->ack_rbf.t_rb) {
+		delay = ack_ts->tstamp - st_ts->tstamp - ack_ts->dur - st_ts->dur;
+
+		sta = rcu_dereference(da->stalist[*st_h]);
+		if (sta)
+			an = (struct ath_node *) sta->drv_priv;
+
+		if (delay > 0) {
+			if (delay < ATH_DYN_MAX_DELAY) {
+				if (an) {
+					u32 ackto = delay + min_to;
+					compute_ts = da->lcompute_ts +
+						     ATH_DYN_COMPUTE_TO;
+					an->ackto = ATH_DYNACK_EWMA(an->ackto,
+							ackto, ATH_DYN_EWMA);
+#ifdef CONFIG_ATH9K_DYNACK_DEBUG
+					printk(KERN_DEBUG "%s:%pM\tackto %u\n",
+						__func__, sta->addr,
+						an->ackto);
+#endif
+					if (time_is_before_jiffies(compute_ts)) {
+						ath_dynack_compute_ackto(sc);
+						da->lcompute_ts = jiffies;
+					}
+				}
+				INCR(*ack_h, ATH_DYN_BUF);
+			}
+			INCR(*st_h, ATH_DYN_BUF);
+		} else
+			INCR(*ack_h, ATH_DYN_BUF);
+	}
+}
+
+/**
+ * ath_dynack_sample_tx_ts - status ts sampling method
+ * @sc: soft carrier
+ * @skb: socket buffer
+ * @ts: tx status info
+ *
+ */
+void ath_dynack_sample_tx_ts(struct ath_softc *sc, struct sk_buff *skb,
+			     struct ath_tx_status *ts)
+{
+	u8 ridx = ts->ts_rateindex;
+	u32 phy = WLAN_RC_PHY_OFDM;
+	const struct ieee80211_rate *rate = NULL;
+	struct ieee80211_sta *sta = NULL;
+	struct ath_dynack *da = &sc->dynack;
+	u16 *head = &da->st_rbf.h_rb, *tail = &da->st_rbf.t_rb;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+
+	if ((info->flags & IEEE80211_TX_CTL_NO_ACK) || da->fix_to)
+		return;
+
+	rcu_read_lock();
+	sta = ieee80211_find_sta_by_ifaddr(sc->hw, hdr->addr1,
+					   hdr->addr2);
+
+	/* bump ack ack to for "late" ack management */
+	if (!sta && (ts->ts_status & ATH9K_TXERR_XRETRY) &&
+	    ieee80211_is_mgmt(hdr->frame_control)) {
+		u16 ackto = ath_dynack_min_to(sc) + 128;
+
+#ifdef CONFIG_ATH9K_DYNACK_DEBUG
+		printk(KERN_DEBUG "%s: %pM late ack\n", __func__, sta->addr);
+#endif
+		ath9k_hw_set_ack_timeout(sc->sc_ah, ackto);
+		ath9k_hw_set_cts_timeout(sc->sc_ah, ackto);
+		da->lcompute_ts = jiffies + ATH_DYN_LATE_ACK_TO;
+		return;
+	}
+
+	spin_lock_bh(&da->qlock);
+	da->st_rbf.ts[*tail].tstamp = ts->ts_tstamp;
+	da->st_rbf.ts[*tail].dur = ts->duration[ts->ts_rateindex];
+	da->stalist[*tail] = sta;
+
+	if (!(info->control.rates[ridx].flags & IEEE80211_TX_RC_MCS)) {
+		struct ieee80211_tx_rate *rates = info->status.rates;
+
+		rate = &sc->sbands[info->band].bitrates[rates[ridx].idx];
+		if ((info->band == IEEE80211_BAND_2GHZ) &&
+		    !(rate->flags & IEEE80211_RATE_ERP_G))
+			phy = WLAN_RC_PHY_CCK;
+		da->st_rbf.ts[*tail].dur -= ath_dynack_get_sifs(sc, phy);
+	}
+
+#ifdef CONFIG_ATH9K_DYNACK_DEBUG
+	printk(KERN_DEBUG "%s: %pM sample %u [dur %u][h %u-t %u]\n",
+	       __func__, hdr->addr1, da->st_rbf.ts[*tail].tstamp,
+		da->st_rbf.ts[*tail].dur, *head, (*tail + 1) % ATH_DYN_BUF);
+#endif
+
+	INCR(*tail, ATH_DYN_BUF);
+	if (*tail == *head)
+		INCR(*head, ATH_DYN_BUF);
+
+	/* compute sta acktimeout */
+	ath_dynack_compute_to(sc);
+	rcu_read_unlock();
+
+	spin_unlock_bh(&da->qlock);
+}
+
+/**
+ * ath_dynack_sample_ack_ts - ack ts sampling method
+ * @sc: soft carrier
+ * @skb: socket buffer
+ * @ts: rx timestamp
+ *
+ */
+void ath_dynack_sample_ack_ts(struct ath_softc *sc, struct sk_buff *skb,
+			      u64 ts)
+{
+	u32 phy = WLAN_RC_PHY_OFDM;
+	const struct ieee80211_rate *rate = NULL;
+	struct ath_dynack *da = &sc->dynack;
+	u16 *head = &da->ack_rbf.h_rb, *tail = &da->ack_rbf.t_rb;
+	struct ieee80211_rx_status *info = IEEE80211_SKB_RXCB(skb);
+
+	if (da->fix_to)
+		return;
+
+	rate = &sc->sbands[info->band].bitrates[info->rate_idx];
+	if ((info->band == IEEE80211_BAND_2GHZ) &&
+	    !(rate->flags & IEEE80211_RATE_ERP_G))
+		phy = WLAN_RC_PHY_CCK;
+
+	spin_lock_bh(&da->qlock);
+	da->ack_rbf.ts[*tail].tstamp = ts;
+	da->ack_rbf.ts[*tail].dur = ath9k_hw_computetxtime(sc->sc_ah,
+		phy, rate->bitrate * 100, skb->len, info->rate_idx,
+		!!(info->flag & RX_FLAG_SHORTPRE));
+	da->ack_rbf.ts[*tail].dur -= ath_dynack_get_sifs(sc, phy);
+
+#ifdef CONFIG_ATH9K_DYNACK_DEBUG
+	printk(KERN_DEBUG "%s: sample %u [dur %u][h %u-t %u]\n",
+		__func__, da->ack_rbf.ts[*tail].tstamp,
+		da->ack_rbf.ts[*tail].dur, *head, (*tail + 1) % ATH_DYN_BUF);
+#endif
+
+	INCR(*tail, ATH_DYN_BUF);
+	if (*tail == *head)
+		INCR(*head, ATH_DYN_BUF);
+
+	rcu_read_lock();
+	/* compute sta acktimeout */
+	ath_dynack_compute_to(sc);
+	rcu_read_unlock();
+
+	spin_unlock_bh(&da->qlock);
+}
+
+/**
+ * ath_dynack_init - init dynack data structure
+ * @sc: soft carrier
+ *
+ */
+void ath_dynack_init(struct ath_softc *sc)
+{
+	/* ackto = slottime + sifs + air delay */
+	u16 ackto = ATH9K_SLOT_TIME_9 + 16 + 64;
+	struct ath_dynack *da = &sc->dynack;
+
+	spin_lock_init(&da->qlock);
+
+	/* init acktimeout */
+	ath9k_hw_set_ack_timeout(sc->sc_ah, ackto);
+	ath9k_hw_set_cts_timeout(sc->sc_ah, ackto);
+}
+
+void ath_dynack_deinit(struct ath_softc *sc)
+{
+}
+
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/recv.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/recv.c	2013-06-15 16:19:16.849822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/recv.c	2013-07-01 00:44:37.593012000 +0200
@@ -27,6 +27,19 @@
 	       (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP);
 }
 
+static bool ath9k_check_bssidmask(struct ath_softc *sc, u8 *mac)
+{
+	int i;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+
+	for (i = 0; i < ETH_ALEN; i++) {
+		if ((common->macaddr[i] & common->bssidmask[i]) !=
+		    (mac[i] & common->bssidmask[i]))
+			return false;
+	}
+	return true;
+}
+
 /*
  * Setup and link descriptors.
  *
@@ -379,7 +392,7 @@
 	u32 rfilt;
 
 	rfilt = ATH9K_RX_FILTER_UCAST | ATH9K_RX_FILTER_BCAST
-		| ATH9K_RX_FILTER_MCAST;
+		| ATH9K_RX_FILTER_MCAST | ATH9K_RX_FILTER_CONTROL;
 
 	/* if operating on a DFS channel, enable radar pulse detection */
 	if (sc->hw->conf.radar_enabled)
@@ -396,9 +409,6 @@
 	if (sc->sc_ah->is_monitoring)
 		rfilt |= ATH9K_RX_FILTER_PROM;
 
-	if (sc->rx.rxfilter & FIF_CONTROL)
-		rfilt |= ATH9K_RX_FILTER_CONTROL;
-
 	if ((sc->sc_ah->opmode == NL80211_IFTYPE_STATION) &&
 	    (sc->nvifs <= 1) &&
 	    !(sc->rx.rxfilter & FIF_BCN_PRBRESP_PROMISC))
@@ -1387,6 +1397,10 @@
 
 		ath9k_apply_ampdu_details(sc, &rs, rxs);
 
+		if (ieee80211_is_ack(hdr->frame_control) &&
+		    ath9k_check_bssidmask(sc, hdr->addr1))
+			ath_dynack_sample_ack_ts(sc, skb, rs.rs_tstamp);
+
 		ieee80211_rx(hw, skb);
 
 requeue_drop_frag:
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/ar9002_mac.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/ar9002_mac.c	2013-04-19 13:53:51.000000000 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/ar9002_mac.c	2013-07-01 00:58:23.317012000 +0200
@@ -341,6 +341,13 @@
 	ts->evm1 = ads->AR_TxEVM1;
 	ts->evm2 = ads->AR_TxEVM2;
 
+	status = ACCESS_ONCE(ads->ds_ctl4);
+	ts->duration[0] = MS(status, AR_PacketDur0);
+	ts->duration[1] = MS(status, AR_PacketDur1);
+	status = ACCESS_ONCE(ads->ds_ctl5);
+	ts->duration[2] = MS(status, AR_PacketDur2);
+	ts->duration[3] = MS(status, AR_PacketDur3);
+
 	return 0;
 }
 
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/mac.h
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/mac.h	2013-06-15 16:19:16.849822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/mac.h	2013-07-01 00:48:24.361012000 +0200
@@ -121,6 +121,7 @@
 	u32 evm0;
 	u32 evm1;
 	u32 evm2;
+	u16 duration[4];
 };
 
 struct ath_rx_status {
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/xmit.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/xmit.c	2013-06-15 16:19:16.417822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/xmit.c	2013-07-04 23:59:07.546733000 +0200
@@ -613,6 +613,7 @@
 			memcpy(info->control.rates, bf->rates,
 			       sizeof(info->control.rates));
 			ath_tx_rc_status(sc, bf, ts, 1, txok ? 0 : 1, txok);
+				ath_dynack_sample_tx_ts(sc, bf->bf_mpdu, ts);
 		}
 		ath_tx_complete_buf(sc, bf, txq, bf_head, ts, txok);
 	} else
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/debug.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/debug.c	2013-06-15 16:19:17.017822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/debug.c	2013-07-05 00:01:24.674733000 +0200
@@ -2201,6 +2201,54 @@
 	.llseek = default_llseek,
 };
 
+static ssize_t read_file_ack_to(struct file *file, char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	char buf[32];
+	unsigned int len, to = ath9k_hw_get_ack_timeout(sc->sc_ah);
+
+	len = sprintf(buf, "%u %c\n", to, (sc->dynack.fix_to) ? 'S' : 'A');
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+/*
+ * enable/disable dynack processing
+ */
+static ssize_t write_file_ack_to(struct file *file, const char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	char buf[32];
+	unsigned long ack_to;
+	ssize_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	if (kstrtoul(buf, 0, &ack_to))
+			return -EINVAL;
+
+	sc->dynack.fix_to = !ack_to;
+
+	/* XXX: remove workqueue */
+	if (sc->dynack.fix_to) {
+		ath9k_hw_set_ack_timeout(sc->sc_ah, ack_to);
+	} else ;
+
+	return count;
+}
+
+static const struct file_operations fops_ack_to = {
+	.read = read_file_ack_to,
+	.write = write_file_ack_to,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
 
 int ath9k_init_debug(struct ath_hw *ah)
 {
@@ -2306,5 +2354,8 @@
 	debugfs_create_file("btcoex", S_IRUSR, sc->debug.debugfs_phy, sc,
 			    &fops_btcoex);
 #endif
+	debugfs_create_file("ack_to", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_ack_to);
+
 	return 0;
 }
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/hw.c
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/hw.c	2013-06-15 16:19:17.061822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/hw.c	2013-07-10 00:52:00.293387000 +0200
@@ -1007,6 +1007,15 @@
 	REG_WRITE(ah, AR_D_GBL_IFS_SIFS, val);
 }
 
+u32 ath9k_hw_get_sifs_time(struct ath_hw *ah)
+{
+	u32 val = REG_READ(ah, AR_D_GBL_IFS_SIFS);
+	struct ath_common *common = ath9k_hw_common(ah);
+
+	return  (common->clockrate) ? val / common->clockrate : 0;
+}
+EXPORT_SYMBOL(ath9k_hw_get_sifs_time);
+
 static void ath9k_hw_setslottime(struct ath_hw *ah, u32 us)
 {
 	u32 val = ath9k_hw_mac_to_clks(ah, us);
@@ -1014,19 +1023,39 @@
 	REG_WRITE(ah, AR_D_GBL_IFS_SLOT, val);
 }
 
-static void ath9k_hw_set_ack_timeout(struct ath_hw *ah, u32 us)
+u32 ath9k_hw_get_slot_time(struct ath_hw *ah)
+{
+	u32 val = REG_READ(ah, AR_D_GBL_IFS_SLOT);
+	struct ath_common *common = ath9k_hw_common(ah);
+
+	return  (common->clockrate) ? val / common->clockrate : 0;
+}
+EXPORT_SYMBOL(ath9k_hw_get_slot_time);
+
+void ath9k_hw_set_ack_timeout(struct ath_hw *ah, u32 us)
 {
 	u32 val = ath9k_hw_mac_to_clks(ah, us);
 	val = min(val, (u32) MS(0xFFFFFFFF, AR_TIME_OUT_ACK));
 	REG_RMW_FIELD(ah, AR_TIME_OUT, AR_TIME_OUT_ACK, val);
 }
+EXPORT_SYMBOL(ath9k_hw_set_ack_timeout);
 
-static void ath9k_hw_set_cts_timeout(struct ath_hw *ah, u32 us)
+u32 ath9k_hw_get_ack_timeout(struct ath_hw *ah)
+{
+	u32 val = REG_READ_FIELD(ah, AR_TIME_OUT, AR_TIME_OUT_ACK);
+	struct ath_common *common = ath9k_hw_common(ah);
+
+	return  (common->clockrate) ? val / common->clockrate : 0;
+}
+EXPORT_SYMBOL(ath9k_hw_get_ack_timeout);
+
+void ath9k_hw_set_cts_timeout(struct ath_hw *ah, u32 us)
 {
 	u32 val = ath9k_hw_mac_to_clks(ah, us);
 	val = min(val, (u32) MS(0xFFFFFFFF, AR_TIME_OUT_CTS));
 	REG_RMW_FIELD(ah, AR_TIME_OUT, AR_TIME_OUT_CTS, val);
 }
+EXPORT_SYMBOL(ath9k_hw_set_cts_timeout);
 
 static bool ath9k_hw_set_global_txtimeout(struct ath_hw *ah, u32 tu)
 {
@@ -1045,6 +1074,7 @@
 void ath9k_hw_init_global_settings(struct ath_hw *ah)
 {
 	struct ath_common *common = ath9k_hw_common(ah);
+	struct ath_softc *sc = common->priv;
 	struct ieee80211_conf *conf = &common->hw->conf;
 	const struct ath9k_channel *chan = ah->curchan;
 	int acktimeout, ctstimeout, ack_offset = 0;
@@ -1129,8 +1159,12 @@
 
 	ath9k_hw_set_sifs_time(ah, sifstime);
 	ath9k_hw_setslottime(ah, slottime);
-	ath9k_hw_set_ack_timeout(ah, acktimeout);
-	ath9k_hw_set_cts_timeout(ah, ctstimeout);
+
+	if (sc->dynack.fix_to) {
+		ath9k_hw_set_ack_timeout(ah, acktimeout);
+		ath9k_hw_set_cts_timeout(ah, ctstimeout);
+	}
+
 	if (ah->globaltxtimeout != (u32) -1)
 		ath9k_hw_set_global_txtimeout(ah, ah->globaltxtimeout);
 
Index: compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/hw.h
===================================================================
--- compat-wireless-2013-04-16.orig/drivers/net/wireless/ath/ath9k/hw.h	2013-06-15 16:19:17.061822187 +0200
+++ compat-wireless-2013-04-16/drivers/net/wireless/ath/ath9k/hw.h	2013-07-10 00:50:33.049387000 +0200
@@ -1039,6 +1039,12 @@
 bool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode);
 void ath9k_hw_update_diag(struct ath_hw *ah);
 
+u32 ath9k_hw_get_sifs_time(struct ath_hw *ah);
+u32 ath9k_hw_get_ack_timeout(struct ath_hw *ah);
+u32 ath9k_hw_get_slottime(struct ath_hw *ah);
+void ath9k_hw_set_ack_timeout(struct ath_hw *ah, u32 us);
+void ath9k_hw_set_cts_timeout(struct ath_hw *ah, u32 us);
+
 #ifdef CONFIG_ATH9K_DEBUGFS
 void ath9k_debug_sync_cause(struct ath_common *common, u32 sync_cause);
 #else
