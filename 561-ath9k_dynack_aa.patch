Index: cwAA/drivers/net/wireless/ath/ath9k/ath9k.h
===================================================================
--- cwAA.orig/drivers/net/wireless/ath/ath9k/ath9k.h	2013-09-25 12:34:12.684307615 +0200
+++ cwAA/drivers/net/wireless/ath/ath9k/ath9k.h	2013-09-25 12:34:12.676307615 +0200
@@ -27,6 +27,7 @@
 #include "common.h"
 #include "mci.h"
 #include "dfs.h"
+#include "dynack.h"
 
 /*
  * Header for the ath9k.ko driver core *only* -- hw code nor any other driver
@@ -266,6 +267,9 @@
 
 	bool sleeping;
 
+	u32 ackto;
+	struct list_head list;
+
 #if defined(CPTCFG_MAC80211_DEBUGFS) && defined(CPTCFG_ATH9K_DEBUGFS)
 	struct dentry *node_stat;
 #endif
@@ -784,6 +788,10 @@
 	atomic_t wow_sleep_proc_intr; /* in the middle of WoW sleep ? */
 	u32 wow_intr_before_sleep;
 #endif
+	struct mutex nodes_mtx;
+	struct list_head nodes;
+
+	struct ath_dynack dynack;
 };
 
 #define SPECTRAL_SCAN_BITMASK		0x10
Index: cwAA/drivers/net/wireless/ath/ath9k/init.c
===================================================================
--- cwAA.orig/drivers/net/wireless/ath/ath9k/init.c	2013-09-25 12:34:12.684307615 +0200
+++ cwAA/drivers/net/wireless/ath/ath9k/init.c	2013-09-25 12:34:12.676307615 +0200
@@ -646,6 +646,7 @@
 	spin_lock_init(&sc->sc_serial_rw);
 	spin_lock_init(&sc->sc_pm_lock);
 	mutex_init(&sc->mutex);
+	mutex_init(&sc->nodes_mtx);
 	tasklet_init(&sc->intr_tq, ath9k_tasklet, (unsigned long)sc);
 	tasklet_init(&sc->bcon_tasklet, ath9k_beacon_tasklet,
 		     (unsigned long)sc);
@@ -656,6 +657,7 @@
 	INIT_DELAYED_WORK(&sc->hw_pll_work, ath_hw_pll_work);
 	setup_timer(&sc->rx_poll_timer, ath_rx_poll, (unsigned long)sc);
 
+	INIT_LIST_HEAD(&sc->nodes);
 	/*
 	 * Cache line size is used to size and align various
 	 * structures used to communicate with the hardware.
Index: cwAA/drivers/net/wireless/ath/ath9k/main.c
===================================================================
--- cwAA.orig/drivers/net/wireless/ath/ath9k/main.c	2013-09-25 12:34:12.684307615 +0200
+++ cwAA/drivers/net/wireless/ath/ath9k/main.c	2013-09-25 12:34:12.680307615 +0200
@@ -328,6 +328,11 @@
 	an->sc = sc;
 	an->sta = sta;
 	an->vif = vif;
+	an->ackto = ath_dynack_min_to(sc);
+
+	mutex_lock(&sc->nodes_mtx);
+	list_add_tail_rcu(&an->list, &sc->nodes);
+	mutex_unlock(&sc->nodes_mtx);
 
 	ath_tx_node_init(sc, an);
 
@@ -341,6 +346,13 @@
 static void ath_node_detach(struct ath_softc *sc, struct ieee80211_sta *sta)
 {
 	struct ath_node *an = (struct ath_node *)sta->drv_priv;
+
+	mutex_lock(&sc->nodes_mtx);
+	list_del_rcu(&an->list);
+	mutex_unlock(&sc->nodes_mtx);
+
+	synchronize_rcu();
+
 	ath_tx_node_cleanup(sc, an);
 }
 
@@ -671,6 +683,8 @@
 
 	ath9k_ps_restore(sc);
 
+	ath_dynack_init(sc);
+
 	return 0;
 }
 
@@ -823,6 +837,8 @@
 
 	mutex_unlock(&sc->mutex);
 
+	ath_dynack_deinit(sc);
+
 	ath_dbg(common, CONFIG, "Driver halt\n");
 }
 
@@ -1791,6 +1807,10 @@
 	mutex_lock(&sc->mutex);
 	ah->coverage_class = coverage_class;
 
+	/* disable dynack processing */
+	sc->dynack.fix_to = true;
+	ath_dynack_deinit(sc);
+
 	ath9k_ps_wakeup(sc);
 	ath9k_hw_init_global_settings(ah);
 	ath9k_ps_restore(sc);
Index: cwAA/drivers/net/wireless/ath/ath9k/dynack.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ cwAA/drivers/net/wireless/ath/ath9k/dynack.h	2013-09-25 12:34:12.680307615 +0200
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2013-2014, Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef ATH9K_DYNACK_H
+#define ATH9K_DYNACK_H
+
+#define ATH_DYN_BUF		64
+#define ATH_DYN_MAX_DELAY	300
+#define ATH_DYN_COMPUTE_TO	(5 * HZ)
+#define ATH_DYN_LATEACK_TO	(30 * HZ)
+
+struct ts_info {
+	int tstamp;
+	int dur;
+};
+
+/**
+ * ath_dyn_rxbuf - ack ring buffer
+ */
+struct ath_dyn_rxbuf {
+	u16 h_rb, t_rb;
+	struct ts_info ts[ATH_DYN_BUF];
+};
+
+/**
+ * ath_dyn_txbuf - tx frame ring buffer
+ */
+struct ath_dyn_txbuf {
+	u16 h_rb, t_rb;
+	u8 status[ATH_DYN_BUF];
+	__le16 fc[ATH_DYN_BUF];
+	struct ts_info ts[ATH_DYN_BUF];
+	struct ieee80211_sta *stalist[ATH_DYN_BUF];
+};
+
+/**
+ * ath_dynack - dyn ack processing info
+ * @fix_to: use static ack timeout
+ * @ackto: current ack timeout
+ * @lto: last ack timeout computation
+ * @qlock: ts queue spinlock
+ * @ack_rbf: ack ts ring buffer
+ * @st_rbf: status ts ring buffer
+ */
+struct ath_dynack {
+	bool fix_to;
+	u32 ackto;
+	unsigned long lto;
+
+	spinlock_t qlock;
+	struct ath_dyn_rxbuf ack_rbf;
+	struct ath_dyn_txbuf st_rbf;
+};
+
+void ath_dynack_init(struct ath_softc *sc);
+void ath_dynack_deinit(struct ath_softc *sc);
+void ath_dynack_sample_tx_ts(struct ath_softc *sc, struct sk_buff *skb,
+			     struct ath_tx_status *ts);
+void ath_dynack_sample_ack_ts(struct ath_softc *sc, struct sk_buff *skb,
+			      u32 ts);
+u32 ath_dynack_min_to(struct ath_softc *sc);
+#endif /* ATH9K_DYNACK_H */
Index: cwAA/drivers/net/wireless/ath/ath9k/Makefile
===================================================================
--- cwAA.orig/drivers/net/wireless/ath/ath9k/Makefile	2013-09-25 12:34:12.684307615 +0200
+++ cwAA/drivers/net/wireless/ath/ath9k/Makefile	2013-09-25 12:34:12.680307615 +0200
@@ -5,7 +5,8 @@
 		recv.o \
 		xmit.o \
 		link.o \
-		antenna.o
+		antenna.o \
+		dynack.o
 
 ath9k-$(CPTCFG_ATH9K_BTCOEX_SUPPORT) += mci.o
 ath9k-$(CPTCFG_ATH9K_LEGACY_RATE_CONTROL) += rc.o
Index: cwAA/drivers/net/wireless/ath/ath9k/dynack.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ cwAA/drivers/net/wireless/ath/ath9k/dynack.c	2013-09-25 12:34:12.680307615 +0200
@@ -0,0 +1,287 @@
+/*
+ * Copyright 2013-2014, Lorenzo Bianconi <lorenzo.bianconi83@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "ath9k.h"
+
+#define EWMA_LEVEL	75
+#define ATH_DYNACK_EWMA(old, new, weight)	\
+	(((new) * (100 - (weight)) + (old) * weight) / 100)
+
+/*
+ * ath_dynack_get_sifs - get sifs time based on phy used
+ * @sc: soft carrier
+ * @phy: phy used
+ */
+static inline u32 ath_dynack_get_sifs(struct ath_softc *sc, int phy)
+{
+	u32 sifs = CCK_SIFS_TIME;
+
+	if (phy == WLAN_RC_PHY_OFDM) {
+		if (IS_CHAN_QUARTER_RATE(sc->sc_ah->curchan))
+			sifs = OFDM_SIFS_TIME_QUARTER;
+		else if (IS_CHAN_HALF_RATE(sc->sc_ah->curchan))
+			sifs = OFDM_SIFS_TIME_HALF;
+		else
+			sifs = OFDM_SIFS_TIME;
+	}
+	return sifs;
+}
+
+/**
+ * ath_dynack_lateack - check if this is late ack
+ * @status: tx status
+ * @fc: frame control
+ */
+static inline bool ath_dynack_lateack(u8 status, __le16 fc)
+{
+	return ((ieee80211_is_assoc_req(fc) || ieee80211_is_assoc_resp(fc)) &&
+		(status & ATH9K_TXERR_XRETRY));
+}
+
+/**
+ * ath_dynack_min_to - get minimum ack timeout
+ * as defined by IEEE 802.11-2007 17.3.8.6
+ * @sc: soft carrier
+ *
+ */
+u32 ath_dynack_min_to(struct ath_softc *sc)
+{
+	const struct ath9k_channel *chan = sc->sc_ah->curchan;
+	u32 slottime = sc->sc_ah->slottime, ack_offset = 0;
+	u32 sifs = (IS_CHAN_5GHZ(chan)) ? 16 : 10;
+
+	if (IS_CHAN_QUARTER_RATE(chan)) {
+		sifs *= 4;
+		slottime = 21;
+		ack_offset = 32;
+	} else if (IS_CHAN_HALF_RATE(chan)) {
+		sifs *= 2;
+		slottime = 13;
+		ack_offset = 16;
+	}
+
+	return slottime + sifs + ack_offset;
+}
+
+/**
+ * ath_dynack_set_ackto - compute ack timeout based on sta timeout
+ * @sc: soft carrier
+ */
+static void ath_dynack_compute_ackto(struct ath_softc *sc)
+{
+	struct ath_node *an;
+	u32 to = 0;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	struct ath_dynack *da = &sc->dynack;
+
+	list_for_each_entry_rcu(an, &sc->nodes, list) {
+		if (an->ackto > to)
+			to = an->ackto;
+	}
+	if (to && da->ackto != to) {
+		ath_dbg(common, DYNACK, "ack timeout %u\n", to);
+		da->ackto = to;
+		ath9k_hw_set_ack_timeout(sc->sc_ah, to);
+		ath9k_hw_set_cts_timeout(sc->sc_ah, to);
+	}
+}
+
+/**
+ * ath_dynack_compute_to - compute sta ack timeout
+ * @sc: soft carrier
+ *
+ * should be called while holding qlock
+ */
+static void ath_dynack_compute_to(struct ath_softc *sc)
+{
+	u8 status;
+	__le16 fc;
+	struct ts_info *ack_ts, *st_ts;
+	int delay, min_to = ath_dynack_min_to(sc);
+	struct ath_node *an = NULL;
+	struct ieee80211_sta *sta = NULL;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	struct ath_dynack *da = &sc->dynack;
+	u16 *ack_h = &da->ack_rbf.h_rb, *st_h = &da->st_rbf.h_rb;
+
+	while (da->st_rbf.h_rb != da->st_rbf.t_rb &&
+	       da->ack_rbf.h_rb != da->ack_rbf.t_rb) {
+		fc = da->st_rbf.fc[*st_h];
+		status = da->st_rbf.status[*st_h];
+		ack_ts = &da->ack_rbf.ts[*ack_h];
+		st_ts = &da->st_rbf.ts[*st_h];
+
+		delay = ack_ts->tstamp - st_ts->tstamp - ack_ts->dur - st_ts->dur;
+
+		sta = rcu_dereference(da->st_rbf.stalist[*st_h]);
+		if (sta)
+			an = (struct ath_node *) sta->drv_priv;
+
+		if (delay > 0) {
+			u32 ackto = delay + min_to;
+			if (delay < ATH_DYN_MAX_DELAY) {
+				if (an) {
+					an->ackto = ATH_DYNACK_EWMA(an->ackto,
+							ackto, EWMA_LEVEL);
+					ath_dbg(common, DYNACK, "{%pM}\tackto"
+						" %u\n", sta->addr, an->ackto);
+					if (time_is_before_jiffies(da->lto)) {
+						ath_dynack_compute_ackto(sc);
+						da->lto = jiffies +
+							  ATH_DYN_COMPUTE_TO;
+					}
+				} else if (ath_dynack_lateack(status, fc)) {
+					/* late ack management */
+					ath_dbg(common, DYNACK, "late ack\n");
+					da->lto = jiffies + ATH_DYN_LATEACK_TO;
+					ath9k_hw_set_ack_timeout(sc->sc_ah,
+								 ackto);
+					ath9k_hw_set_cts_timeout(sc->sc_ah,
+								 ackto);
+				}
+				INCR(*ack_h, ATH_DYN_BUF);
+			}
+			INCR(*st_h, ATH_DYN_BUF);
+		} else
+			INCR(*ack_h, ATH_DYN_BUF);
+	}
+}
+
+/**
+ * ath_dynack_sample_tx_ts - status ts sampling method
+ * @sc: soft carrier
+ * @skb: socket buffer
+ * @ts: tx status info
+ *
+ */
+void ath_dynack_sample_tx_ts(struct ath_softc *sc, struct sk_buff *skb,
+			     struct ath_tx_status *ts)
+{
+	u8 ridx = ts->ts_rateindex;
+	u32 phy = WLAN_RC_PHY_OFDM;
+	const struct ieee80211_rate *rate = NULL;
+	struct ieee80211_sta *sta = NULL;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	struct ath_dynack *da = &sc->dynack;
+	u16 *head = &da->st_rbf.h_rb, *tail = &da->st_rbf.t_rb;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+
+	if ((info->flags & IEEE80211_TX_CTL_NO_ACK) || da->fix_to)
+		return;
+
+	rcu_read_lock();
+	sta = ieee80211_find_sta_by_ifaddr(sc->hw, hdr->addr1,
+					   hdr->addr2);
+
+	spin_lock_bh(&da->qlock);
+	da->st_rbf.status[*tail] = ts->ts_status;
+	da->st_rbf.fc[*tail] = hdr->frame_control;
+	da->st_rbf.ts[*tail].tstamp = ts->ts_tstamp;
+	da->st_rbf.ts[*tail].dur = ts->duration[ts->ts_rateindex];
+	da->st_rbf.stalist[*tail] = sta;
+
+	if (!(info->status.rates[ridx].flags & IEEE80211_TX_RC_MCS)) {
+		struct ieee80211_tx_rate *rates = info->status.rates;
+
+		rate = &sc->sbands[info->band].bitrates[rates[ridx].idx];
+		if ((info->band == IEEE80211_BAND_2GHZ) &&
+		    !(rate->flags & IEEE80211_RATE_ERP_G))
+			phy = WLAN_RC_PHY_CCK;
+		da->st_rbf.ts[*tail].dur -= ath_dynack_get_sifs(sc, phy);
+	}
+
+	ath_dbg(common, DYNACK, "{%pM} tx sample %u [dur %u][h %u-t %u]\n",
+		hdr->addr1, da->st_rbf.ts[*tail].tstamp,
+		da->st_rbf.ts[*tail].dur, *head, (*tail + 1) % ATH_DYN_BUF);
+
+	INCR(*tail, ATH_DYN_BUF);
+	if (*tail == *head)
+		INCR(*head, ATH_DYN_BUF);
+
+	/* compute sta acktimeout */
+	ath_dynack_compute_to(sc);
+
+	spin_unlock_bh(&da->qlock);
+
+	rcu_read_unlock();
+}
+
+/**
+ * ath_dynack_sample_ack_ts - ack ts sampling method
+ * @sc: soft carrier
+ * @skb: socket buffer
+ * @ts: rx timestamp
+ *
+ */
+void ath_dynack_sample_ack_ts(struct ath_softc *sc, struct sk_buff *skb,
+			      u32 ts)
+{
+	u32 phy = WLAN_RC_PHY_OFDM;
+	const struct ieee80211_rate *rate = NULL;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+	struct ath_dynack *da = &sc->dynack;
+	u16 *head = &da->ack_rbf.h_rb, *tail = &da->ack_rbf.t_rb;
+	struct ieee80211_rx_status *info = IEEE80211_SKB_RXCB(skb);
+
+	if (da->fix_to)
+		return;
+
+	rate = &sc->sbands[info->band].bitrates[info->rate_idx];
+	if ((info->band == IEEE80211_BAND_2GHZ) &&
+	    !(rate->flags & IEEE80211_RATE_ERP_G))
+		phy = WLAN_RC_PHY_CCK;
+
+	spin_lock_bh(&da->qlock);
+	da->ack_rbf.ts[*tail].tstamp = ts;
+	da->ack_rbf.ts[*tail].dur = ath9k_hw_computetxtime(sc->sc_ah,
+		phy, rate->bitrate * 100, skb->len, info->rate_idx,
+		!!(info->flag & RX_FLAG_SHORTPRE));
+	da->ack_rbf.ts[*tail].dur -= ath_dynack_get_sifs(sc, phy);
+
+	ath_dbg(common, DYNACK, "rx sample %u [dur %u][h %u-t %u]\n",
+		da->ack_rbf.ts[*tail].tstamp, da->ack_rbf.ts[*tail].dur,
+		*head, (*tail + 1) % ATH_DYN_BUF);
+
+	INCR(*tail, ATH_DYN_BUF);
+	if (*tail == *head)
+		INCR(*head, ATH_DYN_BUF);
+
+	rcu_read_lock();
+	/* compute sta acktimeout */
+	ath_dynack_compute_to(sc);
+	rcu_read_unlock();
+
+	spin_unlock_bh(&da->qlock);
+}
+
+/**
+ * ath_dynack_init - init dynack data structure
+ * @sc: soft carrier
+ *
+ */
+void ath_dynack_init(struct ath_softc *sc)
+{
+	/* ackto = slottime + sifs + air delay */
+	u32 ackto = ATH9K_SLOT_TIME_9 + 16 + 64;
+	struct ath_dynack *da = &sc->dynack;
+
+	spin_lock_init(&da->qlock);
+	da->lto = jiffies;
+	da->fix_to = false;
+	da->ackto = ackto;
+
+	/* init acktimeout */
+	ath9k_hw_set_ack_timeout(sc->sc_ah, ackto);
+	ath9k_hw_set_cts_timeout(sc->sc_ah, ackto);
+}
+
+void ath_dynack_deinit(struct ath_softc *sc)
+{
+}
+
Index: cwAA/drivers/net/wireless/ath/ath9k/recv.c
===================================================================
--- cwAA.orig/drivers/net/wireless/ath/ath9k/recv.c	2013-09-25 12:34:12.684307615 +0200
+++ cwAA/drivers/net/wireless/ath/ath9k/recv.c	2013-09-25 12:34:12.680307615 +0200
@@ -27,6 +27,19 @@
 	       (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_AUTOSLEEP);
 }
 
+static bool ath9k_check_bssidmask(struct ath_softc *sc, u8 *mac)
+{
+	int i;
+	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+
+	for (i = 0; i < ETH_ALEN; i++) {
+		if ((common->macaddr[i] & common->bssidmask[i]) !=
+		    (mac[i] & common->bssidmask[i]))
+			return false;
+	}
+	return true;
+}
+
 /*
  * Setup and link descriptors.
  *
@@ -376,7 +389,7 @@
 	u32 rfilt;
 
 	rfilt = ATH9K_RX_FILTER_UCAST | ATH9K_RX_FILTER_BCAST
-		| ATH9K_RX_FILTER_MCAST;
+		| ATH9K_RX_FILTER_MCAST | ATH9K_RX_FILTER_CONTROL;
 
 	/* if operating on a DFS channel, enable radar pulse detection */
 	if (sc->hw->conf.radar_enabled)
@@ -393,9 +406,6 @@
 	if (sc->sc_ah->is_monitoring)
 		rfilt |= ATH9K_RX_FILTER_PROM;
 
-	if (sc->rx.rxfilter & FIF_CONTROL)
-		rfilt |= ATH9K_RX_FILTER_CONTROL;
-
 	if ((sc->sc_ah->opmode == NL80211_IFTYPE_STATION) &&
 	    (sc->nvifs <= 1) &&
 	    !(sc->rx.rxfilter & FIF_BCN_PRBRESP_PROMISC))
@@ -1385,6 +1395,10 @@
 
 		ath9k_apply_ampdu_details(sc, &rs, rxs);
 
+		if (ieee80211_is_ack(hdr->frame_control) &&
+		    ath9k_check_bssidmask(sc, hdr->addr1))
+			ath_dynack_sample_ack_ts(sc, skb, rs.rs_tstamp);
+
 		ieee80211_rx(hw, skb);
 
 requeue_drop_frag:
Index: cwAA/drivers/net/wireless/ath/ath9k/ar9002_mac.c
===================================================================
--- cwAA.orig/drivers/net/wireless/ath/ath9k/ar9002_mac.c	2013-09-25 12:34:12.684307615 +0200
+++ cwAA/drivers/net/wireless/ath/ath9k/ar9002_mac.c	2013-09-25 12:34:12.680307615 +0200
@@ -341,6 +341,13 @@
 	ts->evm1 = ads->AR_TxEVM1;
 	ts->evm2 = ads->AR_TxEVM2;
 
+	status = ACCESS_ONCE(ads->ds_ctl4);
+	ts->duration[0] = MS(status, AR_PacketDur0);
+	ts->duration[1] = MS(status, AR_PacketDur1);
+	status = ACCESS_ONCE(ads->ds_ctl5);
+	ts->duration[2] = MS(status, AR_PacketDur2);
+	ts->duration[3] = MS(status, AR_PacketDur3);
+
 	return 0;
 }
 
Index: cwAA/drivers/net/wireless/ath/ath9k/mac.h
===================================================================
--- cwAA.orig/drivers/net/wireless/ath/ath9k/mac.h	2013-09-25 12:34:12.684307615 +0200
+++ cwAA/drivers/net/wireless/ath/ath9k/mac.h	2013-09-25 12:34:12.680307615 +0200
@@ -121,6 +121,7 @@
 	u32 evm0;
 	u32 evm1;
 	u32 evm2;
+	u32 duration[4];
 };
 
 struct ath_rx_status {
Index: cwAA/drivers/net/wireless/ath/ath9k/xmit.c
===================================================================
--- cwAA.orig/drivers/net/wireless/ath/ath9k/xmit.c	2013-09-25 12:34:12.684307615 +0200
+++ cwAA/drivers/net/wireless/ath/ath9k/xmit.c	2013-09-25 12:34:12.680307615 +0200
@@ -568,6 +568,9 @@
 				memcpy(tx_info->control.rates, rates, sizeof(rates));
 				ath_tx_rc_status(sc, bf, ts, nframes, nbad, txok);
 				rc_update = false;
+
+				if (bf == bf->bf_lastbf)
+					ath_dynack_sample_tx_ts(sc, bf->bf_mpdu, ts);
 			}
 
 			ath_tx_complete_buf(sc, bf, txq, &bf_head, ts,
@@ -668,6 +671,7 @@
 			memcpy(info->control.rates, bf->rates,
 			       sizeof(info->control.rates));
 			ath_tx_rc_status(sc, bf, ts, 1, txok ? 0 : 1, txok);
+			ath_dynack_sample_tx_ts(sc, bf->bf_mpdu, ts);
 		}
 		ath_tx_complete_buf(sc, bf, txq, bf_head, ts, txok);
 	} else
Index: cwAA/drivers/net/wireless/ath/ath9k/debug.c
===================================================================
--- cwAA.orig/drivers/net/wireless/ath/ath9k/debug.c	2013-09-25 12:34:12.684307615 +0200
+++ cwAA/drivers/net/wireless/ath/ath9k/debug.c	2013-09-25 12:34:12.680307615 +0200
@@ -1935,6 +1935,61 @@
 	.llseek = default_llseek,
 };
 
+/*
+ * enable/disable dynack processing
+ */
+static ssize_t write_file_dynack(struct file *file, const char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	char buf[32];
+	unsigned long disable_dynack;
+	ssize_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	if (kstrtoul(buf, 0, &disable_dynack))
+			return -EINVAL;
+
+	sc->dynack.fix_to = !!disable_dynack;
+
+	if (!sc->dynack.fix_to)
+		sc->dynack.ackto = ATH9K_SLOT_TIME_9 + 16 + 64;
+	ath9k_hw_init_global_settings(sc->sc_ah);
+
+	return count;
+}
+
+static const struct file_operations fops_dynack = {
+	.write = write_file_dynack,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t read_file_ackto(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_hw *ah = sc->sc_ah;
+	char buf[32];
+	unsigned int len;
+
+	len = sprintf(buf, "%u %c\n", ath9k_hw_get_ack_timeout(ah),
+			(sc->dynack.fix_to) ? 'S' : 'A');
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static const struct file_operations fops_ackto = {
+	.read = read_file_ackto,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
 
 int ath9k_init_debug(struct ath_hw *ah)
 {
@@ -2035,5 +2090,10 @@
 	debugfs_create_file("btcoex", S_IRUSR, sc->debug.debugfs_phy, sc,
 			    &fops_btcoex);
 #endif
+	debugfs_create_file("disable_dynack", S_IRUSR | S_IWUSR,
+			    sc->debug.debugfs_phy, sc, &fops_dynack);
+	debugfs_create_file("ack_to", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_ackto);
+
 	return 0;
 }
Index: cwAA/drivers/net/wireless/ath/ath9k/hw.c
===================================================================
--- cwAA.orig/drivers/net/wireless/ath/ath9k/hw.c	2013-09-25 12:34:12.684307615 +0200
+++ cwAA/drivers/net/wireless/ath/ath9k/hw.c	2013-09-25 12:34:12.680307615 +0200
@@ -1005,6 +1005,15 @@
 	REG_WRITE(ah, AR_D_GBL_IFS_SIFS, val);
 }
 
+u32 ath9k_hw_get_sifs_time(struct ath_hw *ah)
+{
+	u32 val = REG_READ(ah, AR_D_GBL_IFS_SIFS);
+	struct ath_common *common = ath9k_hw_common(ah);
+
+	return  (common->clockrate) ? val / common->clockrate : 0;
+}
+EXPORT_SYMBOL(ath9k_hw_get_sifs_time);
+
 static void ath9k_hw_setslottime(struct ath_hw *ah, u32 us)
 {
 	u32 val = ath9k_hw_mac_to_clks(ah, us);
@@ -1012,19 +1021,39 @@
 	REG_WRITE(ah, AR_D_GBL_IFS_SLOT, val);
 }
 
-static void ath9k_hw_set_ack_timeout(struct ath_hw *ah, u32 us)
+u32 ath9k_hw_get_slot_time(struct ath_hw *ah)
+{
+	u32 val = REG_READ(ah, AR_D_GBL_IFS_SLOT);
+	struct ath_common *common = ath9k_hw_common(ah);
+
+	return  (common->clockrate) ? val / common->clockrate : 0;
+}
+EXPORT_SYMBOL(ath9k_hw_get_slot_time);
+
+void ath9k_hw_set_ack_timeout(struct ath_hw *ah, u32 us)
 {
 	u32 val = ath9k_hw_mac_to_clks(ah, us);
 	val = min(val, (u32) MS(0xFFFFFFFF, AR_TIME_OUT_ACK));
 	REG_RMW_FIELD(ah, AR_TIME_OUT, AR_TIME_OUT_ACK, val);
 }
+EXPORT_SYMBOL(ath9k_hw_set_ack_timeout);
+
+u32 ath9k_hw_get_ack_timeout(struct ath_hw *ah)
+{
+	u32 val = REG_READ_FIELD(ah, AR_TIME_OUT, AR_TIME_OUT_ACK);
+	struct ath_common *common = ath9k_hw_common(ah);
+
+	return  (common->clockrate) ? val / common->clockrate : 0;
+}
+EXPORT_SYMBOL(ath9k_hw_get_ack_timeout);
 
-static void ath9k_hw_set_cts_timeout(struct ath_hw *ah, u32 us)
+void ath9k_hw_set_cts_timeout(struct ath_hw *ah, u32 us)
 {
 	u32 val = ath9k_hw_mac_to_clks(ah, us);
 	val = min(val, (u32) MS(0xFFFFFFFF, AR_TIME_OUT_CTS));
 	REG_RMW_FIELD(ah, AR_TIME_OUT, AR_TIME_OUT_CTS, val);
 }
+EXPORT_SYMBOL(ath9k_hw_set_cts_timeout);
 
 static bool ath9k_hw_set_global_txtimeout(struct ath_hw *ah, u32 tu)
 {
@@ -1043,6 +1072,7 @@
 void ath9k_hw_init_global_settings(struct ath_hw *ah)
 {
 	struct ath_common *common = ath9k_hw_common(ah);
+	struct ath_softc *sc = common->priv;
 	struct ieee80211_conf *conf = &common->hw->conf;
 	const struct ath9k_channel *chan = ah->curchan;
 	int acktimeout, ctstimeout, ack_offset = 0;
@@ -1128,6 +1158,11 @@
 
 	ath9k_hw_set_sifs_time(ah, sifstime);
 	ath9k_hw_setslottime(ah, slottime);
+
+	if (!sc->dynack.fix_to) {
+		acktimeout = sc->dynack.ackto;
+		ctstimeout = acktimeout;
+	}
 	ath9k_hw_set_ack_timeout(ah, acktimeout);
 	ath9k_hw_set_cts_timeout(ah, ctstimeout);
 	if (ah->globaltxtimeout != (u32) -1)
Index: cwAA/drivers/net/wireless/ath/ath9k/hw.h
===================================================================
--- cwAA.orig/drivers/net/wireless/ath/ath9k/hw.h	2013-09-25 12:34:12.684307615 +0200
+++ cwAA/drivers/net/wireless/ath/ath9k/hw.h	2013-09-25 12:34:12.680307615 +0200
@@ -1039,6 +1039,12 @@
 bool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode);
 void ath9k_hw_update_diag(struct ath_hw *ah);
 
+u32 ath9k_hw_get_sifs_time(struct ath_hw *ah);
+u32 ath9k_hw_get_ack_timeout(struct ath_hw *ah);
+u32 ath9k_hw_get_slottime(struct ath_hw *ah);
+void ath9k_hw_set_ack_timeout(struct ath_hw *ah, u32 us);
+void ath9k_hw_set_cts_timeout(struct ath_hw *ah, u32 us);
+
 #ifdef CPTCFG_ATH9K_DEBUGFS
 void ath9k_debug_sync_cause(struct ath_common *common, u32 sync_cause);
 #else
Index: cwAA/drivers/net/wireless/ath/ath.h
===================================================================
--- cwAA.orig/drivers/net/wireless/ath/ath.h	2013-09-25 12:34:12.684307615 +0200
+++ cwAA/drivers/net/wireless/ath/ath.h	2013-09-25 12:34:12.684307615 +0200
@@ -219,6 +219,7 @@
  *	AR9462.
  * @ATH_DBG_DFS: radar datection
  * @ATH_DBG_WOW: Wake on Wireless
+ * @ATH_DBG_DYNACK: dynack handling
  * @ATH_DBG_ANY: enable all debugging
  *
  * The debug level is used to control the amount and type of debugging output
@@ -246,6 +247,7 @@
 	ATH_DBG_MCI		= 0x00008000,
 	ATH_DBG_DFS		= 0x00010000,
 	ATH_DBG_WOW		= 0x00020000,
+	ATH_DBG_DYNACK		= 0x00040000,
 	ATH_DBG_ANY		= 0xffffffff
 };
 
